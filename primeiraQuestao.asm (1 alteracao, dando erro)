#include <p16f84a.inc>
; oscilador externo de 8MHz, sem watch dog timer, com power up timer e sem protecao de codigo
    __config _FOSC_XT & _WDT_OFF & _PWRTE_ON & _CP_OFF

VAR_A EQU 0x0C ; endereco onde sera salvo o A
VAR_B EQU 0x0D ; endereco onde sera salvo o B
VAR_C EQU 0x0E ; endereco onde sera salvo o C
VAR_D EQU 0x0F ; endereco onde sera salvo o D
VAR_E EQU 0x10 ; endereco onde sera salvo o E
VAR_F EQU 0x11 ; endereco onde sera salvo o F
VAR_X EQU 0x12 ; endereco onde sera salvo o X
MULTIPLICADOR EQU 0x13 ; endereco onde sera salvo o MULTIPLICADOR
PROCESSING EQU 0x14 
RESULT EQU 0x15
              
    ORG 0x00 ; inicio do programa principal em 0x00
    GOTO PRIN_START ; pula para o inicio do programa

; label instruction parameter comment
    ORG 0x04 ; inicio do programa de interrupcao em 0x04

; inicio do processo de configurar entradas e saidas
PRIN_START
    BCF STATUS, RP0 ; bank 0 (bit clear file)
    CLRF PORTA ; inicializa PORTA limpando-a (clear file)
    BSF STATUS, RP0 ; bank 1 (bit set file)
    MOVLW 0x02 ; W = 0000 0010 (move literal to worker)
    MOVWF TRISA ; todas as portas A como saida e RA1 como entrada (move worker to file)
    
    BCF STATUS, RP0 ; bank 0 (bit clear file)
    CLRF PORTB ; inicializa PORTB limpando-a (clear file)
    BSF STATUS, RP0 ; bank 1 (bit set file)
    MOVLW 0x00 ; W = 0000 0000 (move literal to worker)
    MOVWF TRISB ; todas as portas B como saida (move worker to file)
    BCF STATUS, RP0 ; bank 0 (bit clear file)

    ; MOVLW 0x00 ; W = 0000 0000
    ; MOVWF PORTB ; todas as saidas iniciam em baixo
    ; MOVLW 0x00 ; W = 0000 0000
    ; MOVWF PORTA ; todas as saidas e entrada iniciam em baixo
; termino do processo de configurar entradas e saidas

; inicio do processo de carregar constantes
    MOVLW 0x02 ; W = 0000 0010
    MOVWF VAR_A ; VAR_A = 0x02 = 0000 0010 = 2
    MOVLW 0x03 ; W = 0000 0011
    MOVWF VAR_B ; VAR_B = 0x03 = 0000 0011 = 3
    MOVLW 0xFD ; W = 1111 1101
    MOVWF VAR_C ; VAR_C = 0xFD = 1111 1101 = -3
    MOVLW 0x08
    ADDWF VAR_A,W
    MOVWF VAR_E
    ; MOVF VAR_A,W ; W = VAR_A = 0x02 = 0000 0010 = 2
    ; ADDLW 0x08 ; W = VAR_A + 0x08
    ; MOVWF VAR_E ; VAR_E = W = VAR_A + 0x08 = 0x10   
    MOVLW 0x04
    MOVWF MULTIPLICADOR         
    MOVLW 0x00
    MOVWF PROCESSING
    GOTO LOOP
; termino do processo de carregar constantes
           
; inicio do loop de ler continuamente RA1, ou seja, VAR_D
LOOP
    BTFSC PORTA,RA1 ; pula pr贸xima linha caso seja 0
    GOTO VAR_D_1
    GOTO VAR_D_0

VAR_D_1
    MOVF VAR_C,W
    ; MOVWF VAR_X
    CALL FUNCTION
    GOTO WRITING
    
VAR_D_0 
    MOVF VAR_E,W
    ; MOVWF VAR_X
    CALL FUNCTION
    MOVF RESULT,W
    MOVWF VAR_F
    GOTO WRITING

WRITING       
    ; MOVF VAR_F,W ; W = VAR_F
    MOVLW 0x00
    ADDWF VAR_F,1 ; SOMO VAR_F COM 0 E GUARDO EM VAR_F
    ; MOVWF VAR_F

    BTFSC STATUS,Z ; pula pr贸xima linha caso seja 0
    GOTO NEGATIVE_OR_ZERO
    GOTO LESS_OR_MORE_THEN

LESS_OR_MORE_THEN
    BTFSC VAR_F,7 ; pula pr贸xima linha caso seja 0
    GOTO NEGATIVE_OR_ZERO
    GOTO POSITIVE

POSITIVE
    MOVLW 0x05 ; W = 0000 0101
    MOVWF PORTB
    GOTO LOOP ; fim do programa 

NEGATIVE_OR_ZERO
    MOVLW 0x04 ; W = 0000 0100
    MOVWF PORTB
    GOTO LOOP ; fim do programa 

FUNCTION 
    MOVWF VAR_X ; VAR_X ESTA CARREGADA COM O VALOR DE VAR_E OU VAR_C
    MOVF VAR_X,W
    ; PROCESSING == 0, INICIALMENTE
M_LOOP
    ADDWF PROCESSING,1 ; PROCESSING = W+PROCESSING
    ; MOVWF PROCESSING
    MOVF VAR_X,W
    DECF MULTIPLICADOR,1 ; MULTIPLICADOR = MULTIPLICADOR - 1
    BTFSS STATUS,Z ; pula proxima linha se 1
    GOTO M_LOOP

    ; MOVF PROCESSING,W
    ; MOVWF RESULT
    MOVLW 0x03 
    SUBWF PROCESSING,W
    MOVWF RESULT
    ; MOVF RESULT,W
    ; ADDLW 0xFD
    ; MOVWF VAR_F 
    RETURN
    END
























#include <p16f84a.inc>
    
; oscilador externo de 8MHz, sem watch dog timer, com power up timer e sem protecao de codigo
    __config _FOSC_XT & _WDT_OFF & _PWRTE_ON & _CP_OFF
    
SAVE_W EQU 0x0C ; endereco onde sera salvo o W
SAVE_STATUS EQU 0x0D ; endereco onde sera salvo o STATUS de controle
VALOR_SENSOR_0 EQU 0x0E ; endereco onde sera salvo o VALOR_SENSOR_0
VALOR_SENSOR_1 EQU 0x0F ; endereco onde sera salvo o VALOR_SENSOR_1
 
    ORG 0x00 ; inicio do programa principal em 0x00
    GOTO PRIN_START ; pula para o inicio do programa
    
; label instruction parameter comment
    ORG 0x04 ; inicio do programa de interrupcao em 0x04
    
; inicio do processo de salvar o W e o STATUS
    MOVWF SAVE_W ; SAVE_W = W
    MOVF STATUS,W ; W = STATUS
    MOVWF SAVE_STATUS ; SAVE_STATUS = W
; termino do processo de salvar o W e o STATUS
    
; inicio do processo de saber o porque aconteceu a interrupcao
    BCF STATUS, RP0 ; bank 0 (bit clear file)
    BTFSS INTCON,T0IF ; bit que indica interrupcao por overflow por TMR0 (pula se 1)
    GOTO END_INT ; T0IF == 0 (ou seja, nao foi) entao fim
    BTFSS PORTA,RA0 ; T0IF == 1 (ou seja, foi) entao testa RA0
    GOTO RA0_0
    GOTO RA0_1
RA0_0
    BSF PORTA,RA0 ; T0IF == 1 &amp;&amp; RA0 == 0 entao RA0 = 1
    GOTO END_INT
RA0_1
    BCF PORTA,RA0 ; T0IF == 1 &amp;&amp; RA0 == 1 entao RA0 = 0
END_INT
; termino do processo de saber o porque aconteceu a interrupcao
    
; colocando 0xF8 em TRM0
    MOVLW 0xF8 ; W = 1111 1000
    MOVWF TMR0 ; TMR0 = W = 1111 1000
    
; inicio do processo de restauracao do W e STATUS
    MOVF SAVE_STATUS,W ; W = SAVE_STATUS
    MOVWF STATUS ; STATUS = W = SAVE_STATUS
    MOVF SAVE_W,W ; W = SAVE_W
; termino do processo de restauracao do W e STATUS
    
    BCF INTCON, T0IF ; zera a bandeira de overflow do TMR0
    RETFIE ; sai do programa de interrupcao
; termino do programa de interrupcao
    
; inicio do processo de configurar entradas e saidas
PRIN_START
    BCF STATUS, RP0 ; bank 0 (bit clear file)
    CLRF PORTA ; inicializa PORTA limpando-a (clear file)
    CLRF PORTB ; inicializa PORTB limpando-a (clear file)
    BSF STATUS, RP0 ; bank 1 (bit set file)
    MOVLW 0xFE ; W = 1111 1110 (move literal to worker)
    MOVWF TRISA ; todas as portas A como entrada, RA0 saida do clock (move worker to file)
    MOVLW 0x00 ; W = 0000 0000 (move literal to worker)
    MOVWF TRISB ; todas as portas B como saida (move worker to file)
    BCF STATUS, RP0 ; bank 0 (bit clear file)
    MOVLW 0xFF ; W = 1111 1111
    MOVWF PORTB ; todas as saidas iniciam em alto
    MOVLW 0xFF ; W = 1111 1111
    MOVWF PORTA ; todas as entradas e saida (RA0) iniciam em alto
; termino do processo de configurar entradas e saidas
    
; inicio do processo de carregar constantes
    MOVLW 0x31 ; W = 0011 0001
    MOVWF VALOR_SENSOR_0 ; VALOR_SENSOR_0 = 0x31 = 0011 0001
    MOVLW 0x75 ; W = 0111 0101
    MOVWF VALOR_SENSOR_1 ; VALOR_SENSOR_1 = 0x75 = 0111 0101
; termino do processo de carregar constantes
    
; inicio da configuracao do TMR0
    BSF STATUS, RP0 ; bank 1 (bit set file)
    BCF OPTION_REG,T0CS ; seleciona &quot;timer mode&quot; (ou seja, clock interno)
    BCF OPTION_REG, PSA ; pre-escalar definido pelo modulo do timer0
    BSF OPTION_REG, PS2
    BSF OPTION_REG, PS1
    BSF OPTION_REG, PS0 ; 111 = 1:256
    BCF STATUS, RP0 ; bank 0 (bit clear file)
    MOVLW 0xF8 ; W = 1111 1000
    MOVWF TMR0 ; TMR0 = W = 1111 1000
    BSF INTCON, GIE ; habilita interrupcoes sem mascara
    BSF INTCON, T0IE ; habilita interrupcao TRM0, TRM0 comeca a incrementar
; termino da configuracao do TMR0
    
; inicio do loop de ler continuamente RA1
LOOP
    BTFSC PORTA,RA1; pula pr贸xima linha caso seja 0
    GOTO SENSOR_1
    GOTO SENSOR_0
SENSOR_1
    MOVLW VALOR_SENSOR_1 ; W = 0x75 = 0111 0101
    MOVWF PORTB ; PORTB = W = 0x75 = 1 = 0111 0101
    GOTO LOOP ; volta para loop
SENSOR_0
    MOVLW VALOR_SENSOR_0 ; W = 0x31 = 0011 0001
    MOVWF PORTB ; PORTB = W = 0x31 = 0 = 0011 0001
    GOTO LOOP ; volta para loop
    
	END

